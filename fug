#!/bin/bash

function usage() {
cat << EOF

fug - faster and uglier than fig.

Builds, starts and stops docker containers. Can also be used to view the docker log
files. Uses ./fug.yml for configuration, which is similar syntactically to Fig's fig.yml.

USAGE:

    $(basename $0) [-c FILE] [-d [NAMES]] [-l [NAMES]] [-b [NAMES]] [-s [NAMES]] [-v] [-h]

OPTIONS:

    -c FILE         config file, default: ./fug.yml
    -d [NAMES]      run in daemon mode
    -l [NAMES]      show logs
    -b [NAMES]      build services
    -B [NAMES]      build services, without using cache
    -s [NAMES]      stop containers
    -v              verbose debugging
    -h              display this help

When run with no arguments, fug will start all services in the foreground. If the
containers haven't been built yet, fug will attempt to build them.

The list of services can be defined on the command line, or in the environment var
called DOCKER_SERVICES.

eg:
fug -d service1 service2
fug -l service1 service2

or:
DOCKER_SERVICES="service1 service2"
fug -d
fug -l

Fug looks for a fug.yml file that defines the manner in which docker run is invoked for
each service. The fug.yml file supports environment variables in \${SOMEVAR} format and
can have an ALL build target for settings that should be applied to all services.

EOF
}

function get_ops() {
  # We are reinventing getopts because I want support for optional parameters,
  # and I want support for space separated non-shell-escaped parameters, eg:
  # fug -b target1 target2 and fug -b. May I offer a hearty F.U. to getopts,
  # getopt et al, get off my lawn!
  #
  # This function populates the global associative array $CLI of the users
  # command line arguments, eg: CLI["-d"]="arg1 arg2"

  local -A FP_START FP_END
  local FLAG=""
  local k=0

  for i in $@; do
    let k=k+1
    if [ "${i:0:1}" == "-" ]; then
      [ -n "${FLAG}" ] && FP_END[$FLAG]=$(($k-${FP_START[$FLAG]}))
      FLAG=${i}
      FP_START[$FLAG]=$(($k+1))
    fi
    [ -n "${FLAG}" ] && [ -z ${FP_END[$FLAG]} ] && FP_END[$FLAG]=${#@}
  done

  for f in ${!FP_START[@]}; do
    if [ -n "${FP_START[$f]}" ]; then
      CLI[$f]=${@:${FP_START[$f]}:${FP_END[$f]}}
    fi
  done
}

# if the flag isn't in here, then it ain't valid
function validate_ops() {
  local -A CLI_VALID CLI_MANDATORY
  # ooh aren't we cheeky, generating the valid cli options from the usage function
  while read -r line; do
    local f=$(echo "$line" | grep -Eo '^\s*-[A-Za-z]')
    local t=$(echo "$line" | grep -Eo '^\s*-[A-Za-z] [A-Za-z]')
    [ "$f" ] && CLI_VALID[$f]=1
    [ "$t" ] && CLI_MANDATORY[$f]=1
  done <<< "$(usage)"

  # loop through the switches the user has typed in
  for i in ${!CLI[@]}; do
    [ -z "${CLI_VALID[$i]}" ] && echo "not supported: $i" && exit 1
    [ "${CLI_MANDATORY[$i]}" ] && [ -z "${CLI[$i]}" ] && echo "empty value for: $i" && exit 1
  done
}

# when a command line flag is supplied without args
function default_ops() {
  local -A CLI_DEFAULTS
  CLI_DEFAULTS["-d"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-l"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-b"]=$DOCKER_SERVICES_REVERSED
  CLI_DEFAULTS["-B"]=$DOCKER_SERVICES_REVERSED
  CLI_DEFAULTS["-s"]=$DOCKER_SERVICES_REVERSED

  for f in ${!CLI[@]}; do
    if [ -z "${CLI[$f]}" ] && [ "${CLI_DEFAULTS[$f]}" ]; then
      CLI[$f]=${CLI_DEFAULTS[$f]}
    fi
  done
}

function get_docker_run_args() {
  # parse the fug.yml configuration file
  for i in $(${FUGDIR}/shyaml keys < ${OPCONF}); do
    DOCKER_LINKS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.links       < ${OPCONF} | sed 's/- / /g')
    DOCKER_ENV[$i]+=$(    ${FUGDIR}/shyaml get-value ${i}.environment < ${OPCONF} | sed 's/- / /g')
    DOCKER_EXTRA[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.extra       < ${OPCONF} | sed 's/- / /g')
    DOCKER_ROOT[$i]+=$(   ${FUGDIR}/shyaml get-value ${i}.privileged  < ${OPCONF} | sed 's/- / /g')
    DOCKER_PORTS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.ports       < ${OPCONF} | sed 's/- / /g')
    DOCKER_VOLUMES[$i]+=$(${FUGDIR}/shyaml get-value ${i}.volumes     < ${OPCONF} | sed 's/- / /g')
    DOCKER_HOSTS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.hosts       < ${OPCONF} | sed 's/- / /g')
  done

  # if attributes are a part of the ALL target, then apply them to every target
  for i in $DOCKER_SERVICES; do
    [ -n "${DOCKER_LINKS['ALL']}" ]   && DOCKER_LINKS[$i]+=" ${DOCKER_LINKS['ALL']}"
    [ -n "${DOCKER_ENV['ALL']}" ]     && DOCKER_ENV[$i]+=" ${DOCKER_ENV['ALL']}"
    [ -n "${DOCKER_EXTRA['ALL']}" ]   && DOCKER_EXTRA[$i]+=" ${DOCKER_EXTRA['ALL']}"
    [ -n "${DOCKER_ROOT['ALL']}" ]    && DOCKER_ROOT[$i]+=" ${DOCKER_ROOT['ALL']}"
    [ -n "${DOCKER_PORTS['ALL']}" ]   && DOCKER_PORTS[$i]+=" ${DOCKER_PORTS['ALL']}"
    [ -n "${DOCKER_VOLUMES['ALL']}" ] && DOCKER_VOLUMES[$i]+=" ${DOCKER_VOLUMES['ALL']}"
    [ -n "${DOCKER_HOSTS['ALL']}" ]   && DOCKER_HOSTS[$i]+=" ${DOCKER_HOSTS['ALL']}"
    [ -n "${DOCKER_PATH['ALL']}" ]    && DOCKER_PATH[$i]+=" ${DOCKER_PATH['ALL']}"
  done

  # build up command line argument to docker run
  for i in $DOCKER_SERVICES; do
    for v in ${DOCKER_LINKS[$i]};   do ARGS[$i]+=" --link=${NAME}_${v}:${v}"; done
    for v in ${DOCKER_ENV[$i]};     do ARGS[$i]+=" --env=$v";                 done
    for v in ${DOCKER_VOLUMES[$i]}; do ARGS[$i]+=" --volume=$v";              done
    for v in ${DOCKER_ROOT[$i]};    do ARGS[$i]+=" --privileged";             done
    for v in ${DOCKER_HOSTS[$i]};   do ARGS[$i]+=" --add-host=$v";            done
    for v in ${DOCKER_EXTRA[$i]};   do ARGS[$i]+=" $v";                       done
    for v in ${DOCKER_PORTS[$i]};   do [ "$v" != "auto" ] && ARGS[$i]+=" --publish=$v"; done
  done
}

function get_docker_build_args() {
  # parse the fug.yml configuration file
  for i in $(${FUGDIR}/shyaml keys < ${OPCONF}); do
    DOCKER_PATH[$i]+=$(   ${FUGDIR}/shyaml get-value ${i}.build       < ${OPCONF} | sed 's/- / /g')
  done
}

function stop_containers() {
  local services=$@
  for i in $services; do
    kill1 $i
    kill2 $i
  done
}

function kill1() {
  local i=$1
  local ids="$(docker ps -a | grep ${NAME}_${i} | awk '{print $1}')"
  for x in $ids; do
    if [ -n "${x}" ]; then
      echo " * Stopping ${NAME}_${i} ($x)"
      docker stop $x > /dev/null
    fi
  done
}

function kill2() {
  local i=$1
  local ids="$(docker ps -a | grep ${NAME}_${i} | awk '{print $1}')"
  for x in $ids; do
    if [ -n "${x}" ]; then
      echo " * Removing ${NAME}_${i} ($x)"
      docker rm -f $x
    fi
  done
}

function halt_log() {
  services=$@
  for i in $services; do
    local ids="$(docker ps | grep ${NAME}_${i} | awk '{print $1}')"
    for i in $ids; do
      if [ -n "${i}" ]; then
        local pid=$(pgrep -f "docker logs -f ${i}")
        [ -n "${pid}" ] && kill $pid
      fi
    done
  done
}

function listen() {
  while true; do
    read x
    sleep 1
  done
}

function build_container() {
  # build new images
  local i=$1
  local p
  if [ -n "${DOCKER_PATH[$i]}" ]; then
    p="${DOCKER_PATH[$i]}"
  else
    p="./${i}/"
  fi
  [ -n "${OPBUILD_NOCACHE}" ] && nocache="--no-cache"
  local cmd="docker build ${nocache} -t ${NAME}_${i} $p"

  # if verbose, then we run in non-concurrent build mode
  if [ -n "${OPVERBOSE}" ]; then
    echo " * Building $i (${NAME}_${i}) "
    $cmd
    if [ "$?" != "0" ]; then
     echo "*** Build container failed: $i"
     exit 1
    fi
  # else, build containers concurrently
  else
    $cmd > /dev/null 2>&1 &
    PIDS[$i]="$!"
  fi
}

function watch_containers_build() {
  # EXITS will contain docker build exit statuses
  local -A EXITS
  local ticker
  trap "{ echo ''; exit 1; }" SIGINT
  while [ true ]; do
    # if no more processes, then break loop
    [ "${#PIDS[@]}" == "0" ] && break

    ((ticker++))

    for i in ${!PIDS[@]}; do
      if [ "${PIDS[$i]}" ] && [ "$(ps -p${PIDS[$i]} --no-headers)" ]; then
        EXITS[$i]="-1"
      elif [ "${PIDS[$i]}" ]; then
        wait ${PIDS[$i]}
        EXITS[$i]=$? # exit status of container build process
        unset PIDS[$i]
      fi
    done

    # echo out an updating status line
    if [ -z "${OPVERBOSE}" ]; then
      echo -n "Build(${ticker}s): "
      for i in $OPBUILD; do
        if [ "${EXITS[$i]}" == "-1" ] ; then
          echo -n "$i "
        elif [ "${EXITS[$i]}" != "0" ] ; then
          echo -ne "${red}${i}${end_colour} "
        else
          echo -ne "${green}${i}${end_colour} "
        fi
      done
      echo -ne '\r' # backspace the whole line
    fi

    sleep 1
  done

  [ -z "${OPVERBOSE}" ] && echo ""

  for i in ${!EXITS[@]}; do
    if [ "${EXITS[$i]}" != "0" ]; then
     echo "*** Build container failed: $i"
     exit 1
   fi
  done
}



# These are the currently supported docker settings
declare -A DOCKER_LINKS DOCKER_ENV DOCKER_EXTRA DOCKER_ROOT
declare -A DOCKER_PORTS DOCKER_VOLUMES DOCKER_HOSTS DOCKER_PATH

# where `docker run` cli options are constructed, PIDS is for build process ids
declare -A ARGS PIDS

# Location of script
FUGDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

# Some colours
red='\033[0;31m'
green='\033[0;32m'
end_colour='\033[0m' # No Color

# No services?
[ -z "${DOCKER_SERVICES}" ] && echo "DOCKER_SERVICES is not set" && exit 1
for i in $DOCKER_SERVICES; do DOCKER_SERVICES_REVERSED="$i $DOCKER_SERVICES_REVERSED"; done

# Setup the valid cli options and their defaults
declare -A CLI
get_ops "$@"
validate_ops
default_ops

# make the ops slightly easier to read. The +q hack permits
# checking for array keys that have empty values
[ -n "${CLI["-c"]+q}" ] && OPCONF=${CLI["-c"]}
[ -n "${CLI["-d"]+q}" ] && OPDAEMON=${CLI["-d"]}
[ -n "${CLI["-l"]+q}" ] && OPLOGS=${CLI["-l"]}
[ -n "${CLI["-b"]+q}" ] && OPBUILD=${CLI["-b"]}
[ -n "${CLI["-B"]+q}" ] && OPBUILD=${CLI["-B"]} OPBUILD_NOCACHE=1
[ -n "${CLI["-s"]+q}" ] && OPSTOP=${CLI["-s"]}
[ -n "${CLI["-v"]+q}" ] && OPVERBOSE=1
[ -n "${CLI["-h"]+q}" ] && OPHELP=1

# helper monkeys
[ -n "${OPVERBOSE}" ] && env && set -o xtrace
[ -n "${OPHELP}" ]    && usage && exit 0

# get the configuration
[ -z "${OPCONF}" ]    && OPCONF="./fug.yml"
[ ! -f "${OPCONF}" ]  && echo "no configuration file found: ${OPCONF}" && exit 1

# get an alphanumeric name for the containers base on the current working directory
NAME="fug_$(basename $(pwd) | sed 's/[^A-Za-z0-9]//')"

# load up build args from fug.yml
get_docker_build_args

# stop mode
if [ -n "${OPSTOP}" ]; then
  stop_containers ${OPSTOP}
  exit $?
fi

# show logs
if [ -n "${OPLOGS}" ]; then
  trap "{ halt_log ${OPLOGS} ; exit 0; }" SIGINT
  for i in ${OPLOGS}; do
    id="$(docker ps | grep "${NAME}_${i}" | awk '{print $1}')"
    if [ -n "${id}" ]; then
      docker logs -f $id &
      go=1
    else
      echo "Not started: ${NAME}_${i}"
    fi
  done
  [ -n "${go}" ] && listen
  exit $?
fi


# if we're running in the foreground, then control-c stops the containers in reverse order
if [ -z "${OPBUILD}" ] && [ -z "${OPDAEMON}" ] ; then
  trap "{ stop_containers ${DOCKER_SERVICES_REVERSED}; exit 0; }" SIGINT
fi

# If running -b then build and exit
if [ -n "${OPBUILD}" ]; then
  for i in ${OPBUILD}; do
    build_container ${i}
  done
  watch_containers_build
  exit $?
fi

services=$DOCKER_SERVICES
[ -n "${OPDAEMON}" ] && services=${OPDAEMON}

# default is to run the container - but check if it exists first if not, build it
for i in $services; do
  exists=$(docker images | grep "${NAME}_${i}")
  if [ -z "${exists}" ]; then
    build_container ${i}
  fi
done
[ -z "${exists}" ] && watch_containers_build


get_docker_run_args
ORIG_PORT=$PORT
ticker=25000
for i in $services; do
  kill1 $i
  kill2 $i

  echo " * Starting $i"
  [ -f "${i}/environment" ] && ARGS[$i]+=" --env-file=./${i}/environment"

  # if starting on an "auto" port, automatically assign the port to start on
  PORT=$ORIG_PORT
  if [ "$(echo ${DOCKER_PORTS[$i]} | grep auto)" ]; then
    ((ticker=ticker+10))
    PORT=$ticker
    ARGS[$i]+=" --publish=${PORT}:${PORT}"
    customportname="PORT_${i}"
    export ${customportname}=$PORT
  fi

  removerestart=" --rm "
  [ "${OPDAEMON}" ] && removerestart=" --restart=always "
  cmd="docker run $removerestart ${ARGS[$i]} --name=${NAME}_${i} ${NAME}_${i}"
  if [ -z "${OPDAEMON}" ]; then
    $cmd &
  else
    nohup $cmd > /dev/null 2>&1 &
  fi
  [ "${DOCKER_LINKS[$i]}" ] && sleep 0.5
done

# If not in daemon mode then await a control-c/SIGINT
if [ -z "${OPDAEMON}" ]; then
  listen
fi


