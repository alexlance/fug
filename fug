#!/bin/bash

function usage() {
cat << EOF

fug - faster and uglier than fig.

Builds, starts and stops docker containers. Can also be used to view the docker log
files. Uses ./fug.yml for configuration, which is similar syntactically to Fig's fig.yml.

USAGE:

    $(basename $0) [-c FILE] [-d [NAMES]] [-l [NAMES]] [-b [NAMES]] [-s [NAMES]] [-v] [-h]

OPTIONS:

    -c FILE         config file, default: ./fug.yml
    -d [NAMES]      run in daemon mode
    -l [NAMES]      show logs
    -L [NAMES]      show logs and exit
    -b [NAMES]      build services
    -B [NAMES]      build services, without using cache
    -s [NAMES]      stop containers
    -v              verbose debugging
    -h              display this help

The list of services can be defined on the command line, or in the environment var
called DOCKER_SERVICES.

eg:
fug -d service1 service2
fug -l service1 service2

or:
DOCKER_SERVICES="service1 service2"
fug -d
fug -l

Fug looks for a fug.yml file that defines the manner in which docker run is invoked for
each service. The fug.yml file supports environment variables in \${SOMEVAR} format and
can have an ALL build target for settings that should be applied to all services.

EOF
}

function get_ops() {
  # We are reinventing getopts because I want support for optional parameters,
  # and I want support for space separated non-shell-escaped parameters, eg:
  # fug -b target1 target2 and fug -b. May I offer a hearty F.U. to getopts,
  # getopt et al, get off my lawn!
  #
  # This function populates the global associative array $CLI of the users
  # command line arguments, eg: CLI["-d"]="arg1 arg2"

  local -A FP_START FP_END
  local FLAG=""
  local k=0

  for i in $@; do
    let k=k+1
    if [ "${i:0:1}" == "-" ]; then
      [ -n "${FLAG}" ] && FP_END[$FLAG]=$(($k-${FP_START[$FLAG]}))
      FLAG=${i}
      FP_START[$FLAG]=$(($k+1))
    fi
    [ -n "${FLAG}" ] && [ -z ${FP_END[$FLAG]} ] && FP_END[$FLAG]=${#@}
  done

  for f in ${!FP_START[@]}; do
    if [ -n "${FP_START[$f]}" ]; then
      CLI[$f]=${@:${FP_START[$f]}:${FP_END[$f]}}
    fi
  done
}

# grab valid command line args from usage() function
function validate_ops() {
  local -A CLI_VALID CLI_MANDATORY
  while read -r line; do
    local f=$(echo "$line" | grep -Eo '^\s*-[A-Za-z]')
    local t=$(echo "$line" | grep -Eo '^\s*-[A-Za-z] [A-Za-z]')
    [ "$f" ] && CLI_VALID[$f]=1
    [ "$t" ] && CLI_MANDATORY[$f]=1
  done <<< "$(usage)"

  # loop through the switches the user has typed in
  for i in ${!CLI[@]}; do
    [ -z "${CLI_VALID[$i]}" ] && echo "not supported: $i" && exit 1
    [ "${CLI_MANDATORY[$i]}" ] && [ -z "${CLI[$i]}" ] && echo "empty value for: $i" && exit 1
  done
}

# when a command line flag is supplied without args
function default_ops() {
  local -A CLI_DEFAULTS
  CLI_DEFAULTS["-d"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-l"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-L"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-b"]=$DOCKER_SERVICES_REVERSED
  CLI_DEFAULTS["-B"]=$DOCKER_SERVICES_REVERSED
  CLI_DEFAULTS["-s"]=$DOCKER_SERVICES_REVERSED

  for f in ${!CLI[@]}; do
    if [ -z "${CLI[$f]}" ] && [ "${CLI_DEFAULTS[$f]}" ]; then
      CLI[$f]=${CLI_DEFAULTS[$f]}
    fi
  done
}

function get_docker_run_args() {
  # parse the fug.yml configuration file
  for i in $(${FUGDIR}/shyaml keys < ${OPCONF}); do
    DOCKER_LINKS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.links       < ${OPCONF} | sed 's/- / /g')
    DOCKER_ENV[$i]+=$(    ${FUGDIR}/shyaml get-value ${i}.environment < ${OPCONF} | sed 's/- / /g')
    DOCKER_ENVFILE[$i]+=$(${FUGDIR}/shyaml get-value ${i}.env-file    < ${OPCONF} | sed 's/- / /g')
    DOCKER_EXTRA[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.extra       < ${OPCONF} | sed 's/- / /g')
    DOCKER_ROOT[$i]+=$(   ${FUGDIR}/shyaml get-value ${i}.privileged  < ${OPCONF} | sed 's/- / /g')
    DOCKER_PORTS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.ports       < ${OPCONF} | sed 's/- / /g')
    DOCKER_VOLUMES[$i]+=$(${FUGDIR}/shyaml get-value ${i}.volumes     < ${OPCONF} | sed 's/- / /g')
    DOCKER_HOSTS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.hosts       < ${OPCONF} | sed 's/- / /g')
    if [ "$(${FUGDIR}/shyaml get-value ${i}.sibling < ${OPCONF} | sed 's/- / /g')" ]; then
      DOCKER_SIBLINGS[$i]=1
    fi
  done

  # if attributes are a part of the ALL target, then apply them to every target
  for i in $DOCKER_SERVICES; do
    [ "${DOCKER_SIBLINGS[$i]}" ] && continue; # don't let the ALL target, affect siblings
    [ -n "${DOCKER_LINKS['ALL']}" ]   && DOCKER_LINKS[$i]+=" ${DOCKER_LINKS['ALL']}"
    [ -n "${DOCKER_ENV['ALL']}" ]     && DOCKER_ENV[$i]+=" ${DOCKER_ENV['ALL']}"
    [ -n "${DOCKER_ENVFILE['ALL']}" ] && DOCKER_ENVFILE[$i]+=" ${DOCKER_ENVFILE['ALL']}"
    [ -n "${DOCKER_EXTRA['ALL']}" ]   && DOCKER_EXTRA[$i]+=" ${DOCKER_EXTRA['ALL']}"
    [ -n "${DOCKER_ROOT['ALL']}" ]    && DOCKER_ROOT[$i]+=" ${DOCKER_ROOT['ALL']}"
    [ -n "${DOCKER_PORTS['ALL']}" ]   && DOCKER_PORTS[$i]+=" ${DOCKER_PORTS['ALL']}"
    [ -n "${DOCKER_VOLUMES['ALL']}" ] && DOCKER_VOLUMES[$i]+=" ${DOCKER_VOLUMES['ALL']}"
    [ -n "${DOCKER_HOSTS['ALL']}" ]   && DOCKER_HOSTS[$i]+=" ${DOCKER_HOSTS['ALL']}"
    [ -n "${DOCKER_PATH['ALL']}" ]    && DOCKER_PATH[$i]+=" ${DOCKER_PATH['ALL']}"
  done

  # make a list of all services and siblings
  local ALL_SERVICES=$DOCKER_SERVICES
  for i in ${!DOCKER_SIBLINGS[@]}; do
    ALL_SERVICES+=" $i"
  done

  # build up command line argument to docker run
  for i in $ALL_SERVICES; do
    for v in ${DOCKER_LINKS[$i]};   do ARGS[$i]+=" --link=${NAME}_${v}:${v}"; done
    for v in ${DOCKER_ENV[$i]};     do ARGS[$i]+=" --env=$v";                 done
    for v in ${DOCKER_ENVFILE[$i]}; do ARGS[$i]+=" --env-file=./${i}/${v}";   done
    for v in ${DOCKER_VOLUMES[$i]}; do ARGS[$i]+=" --volume=$v";              done
    for v in ${DOCKER_ROOT[$i]};    do ARGS[$i]+=" --privileged";             done
    for v in ${DOCKER_HOSTS[$i]};   do ARGS[$i]+=" --add-host=$v";            done
    for v in ${DOCKER_EXTRA[$i]};   do ARGS[$i]+=" $v";                       done
    for v in ${DOCKER_PORTS[$i]};   do [ "$v" != "auto" ] && ARGS[$i]+=" --publish=$v"; done
  done
}

function get_docker_build_args() {
  # parse the fug.yml configuration file
  for i in $(${FUGDIR}/shyaml keys < ${OPCONF}); do
    DOCKER_PATH[$i]+=$(   ${FUGDIR}/shyaml get-value ${i}.build       < ${OPCONF} | sed 's/- / /g')
  done
}

function stop_containers() {
  local services=$@
  for i in $services; do
    nuke_container $i
  done
}

function stop_siblings() {
  local services=$@
  for i in $services; do
    for sibling_name in ${!DOCKER_SIBLINGS[@]}; do
      nuke_container ${i}_${sibling_name}
    done;
  done
}

function nuke_container() {
  local i=$1
  local ids="$(docker ps -a | grep -E "\b${NAME}_${i}\b" | awk '{print $1}')"
  for x in $ids; do
    if [ -n "${x}" ]; then
      echo " * Stopping ${NAME}_${i} ($x)"
      docker stop -t 0 $x > /dev/null
      docker rm -f $x > /dev/null
    fi
  done
}

function halt_log() {
  services=$@
  for i in $services; do
    local ids="$(docker ps | grep -E "\b${NAME}_${i}\b" | awk '{print $1}')"
    for i in $ids; do
      if [ -n "${i}" ]; then
        local pid=$(pgrep -f "docker logs -f ${i}")
        [ -n "${pid}" ] && kill $pid
      fi
    done
  done
}

function listen() {
  while true; do
    read x
    sleep 1
  done
}

function build_container() {
  # build new images
  local i=$1
  local p
  if [ -n "${DOCKER_PATH[$i]}" ]; then
    p="${DOCKER_PATH[$i]}"
  else
    p="./${i}/"
  fi
  [ -n "${OPBUILD_NOCACHE}" ] && nocache="--no-cache"
  local cmd="docker build ${nocache} -t ${NAME}_${i} $p"

  # if verbose, then we run in non-concurrent build mode
  if [ -n "${OPVERBOSE}" ]; then
    echo " * Building $i (${NAME}_${i}) "
    $cmd
    if [ "$?" != "0" ]; then
     echo "*** Build container failed: $i"
     exit 1
    fi
  # else, build containers concurrently
  else
    $cmd > /dev/null 2>&1 &
    PIDS[$i]="$!"
  fi
}

function watch_containers_build() {
  # EXITS will contain docker build exit statuses
  local -A EXITS
  local ticker
  trap "{ echo ''; exit 1; }" SIGINT
  while [ true ]; do
    # if no more processes, then break loop
    [ "${#PIDS[@]}" == "0" ] && break

    ((ticker++))

    for i in ${!PIDS[@]}; do
      if [ "${PIDS[$i]}" ] && [ "$(ps -p${PIDS[$i]} --no-headers)" ]; then
        EXITS[$i]="-1"
      elif [ "${PIDS[$i]}" ]; then
        wait ${PIDS[$i]}
        EXITS[$i]=$? # exit status of container build process
        unset PIDS[$i]
      fi
    done

    # echo out an updating status line
    if [ -z "${OPVERBOSE}" ]; then
      echo -n "Build(${ticker}s): "
      for i in $OPBUILD; do
        if [ "${EXITS[$i]}" == "-1" ] ; then
          echo -n "$i "
        elif [ "${EXITS[$i]}" != "0" ] ; then
          echo -ne "${red}${i}${end_colour} "
        else
          echo -ne "${green}${i}${end_colour} "
        fi
      done
      echo -ne '\r' # backspace the whole line
    fi
    sleep 1
  done

  [ -z "${OPVERBOSE}" ] && echo ""

  for i in ${!EXITS[@]}; do
    if [ "${EXITS[$i]}" != "0" ]; then
     echo "*** Build container failed: $i"
     exit 1
   fi
  done
}

function inherit_container_environment() {
  local i=$1
  local id=$(docker ps | grep -E "\b${NAME}_${i}\b" | awk '{ print $1 }')
  if [ "${id}" ]; then
    for v in ${DOCKER_ENVFILE[$i]}; do
      unset exportvars
      [ -f "./${i}/${v}" ] && exportvars=$(docker exec $id env | sed 's/\(.*\)=\(.*$\)/export \1="\2"/g' | grep -f ./${i}/${v})
      [ -n "$exportvars" ] && eval "$exportvars"
    done
  fi
}

# These are the currently supported docker settings
declare -A DOCKER_LINKS DOCKER_ENV DOCKER_EXTRA DOCKER_ROOT DOCKER_PORTS
declare -A DOCKER_VOLUMES DOCKER_HOSTS DOCKER_PATH DOCKER_SIBLINGS DOCKER_ENVFILE

# where `docker run` cli options are constructed, PIDS is for build process ids
declare -A ARGS PIDS

# Location of script
FUGDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

# Some colours
red='\033[0;31m'
green='\033[0;32m'
end_colour='\033[0m' # No Color

# No services? Then check current dir
if [ -z "${DOCKER_SERVICES}" ]; then
  for i in *; do
    [ -d "$i" ] && [ -f "$i/Dockerfile" ] && DOCKER_SERVICES+="$i "
  done
fi
[ -z "${DOCKER_SERVICES}" ] && "No services found in current directory or defined in DOCKER_SERVICES" && exit 1
for i in $DOCKER_SERVICES; do DOCKER_SERVICES_REVERSED="$i $DOCKER_SERVICES_REVERSED"; done

# Setup the valid cli options and their defaults
declare -A CLI
get_ops "$@"
validate_ops
default_ops

# make the ops slightly easier to read. The +q hack permits
# checking for array keys that have empty values
[ -n "${CLI["-c"]+q}" ] && OPCONF=${CLI["-c"]}     good=1
[ -n "${CLI["-d"]+q}" ] && OPDAEMON=${CLI["-d"]}   good=1
[ -n "${CLI["-l"]+q}" ] && OPLOGS=${CLI["-l"]}     good=1
[ -n "${CLI["-L"]+q}" ] && OPLOGSEXIT=${CLI["-L"]} good=1
[ -n "${CLI["-b"]+q}" ] && OPBUILD=${CLI["-b"]}    good=1
[ -n "${CLI["-B"]+q}" ] && OPBUILD=${CLI["-B"]}    good=1 OPBUILD_NOCACHE=1
[ -n "${CLI["-s"]+q}" ] && OPSTOP=${CLI["-s"]}     good=1
[ -n "${CLI["-v"]+q}" ] && OPVERBOSE=1             good=1
[ -n "${CLI["-h"]+q}" ] && OPHELP=1                good=1

# helper monkeys
[ -n "${OPVERBOSE}" ] && env && set -o xtrace
[ -n "${OPHELP}" ]    && usage && exit 0
[ -z "${good}" ]      && usage && exit 1

# get the configuration
[ -z "${OPCONF}" ]    && OPCONF="./fug.yml"
[ ! -f "${OPCONF}" ]  && echo "no configuration file found: ${OPCONF}" && exit 1

# get an alphanumeric name for the containers base on the current working directory
NAME="fug_$(basename $(pwd) | sed 's/[^A-Za-z0-9]//g')"

# load up build args from fug.yml
get_docker_build_args

# stop mode
if [ -n "${OPSTOP}" ]; then
  get_docker_run_args # to discover siblings
  stop_siblings ${OPSTOP}
  stop_containers ${OPSTOP}
  exit $?
fi

# show logs, like a tail -f
if [ -n "${OPLOGS}" ]; then
  trap "{ halt_log ${OPLOGS} ; exit 0; }" SIGINT
  for i in ${OPLOGS}; do
    id="$(docker ps | grep -E "\b${NAME}_${i}\b" | awk '{print $1}')"
    if [ -n "${id}" ]; then
      docker logs -f $id &
      go=1
    else
      echo "Not started: ${NAME}_${i}"
    fi
  done
  [ -n "${go}" ] && listen
  exit $?
fi

# show logs and exit
if [ -n "${OPLOGSEXIT}" ]; then
  for i in ${OPLOGSEXIT}; do
    id="$(docker ps | grep -E "\b${NAME}_${i}\b" | awk '{print $1}')"
    if [ -n "${id}" ]; then
      docker logs $id
    else
      echo "Not started: ${NAME}_${i}"
    fi
  done
  exit $?
fi

# If running -b then build and exit
if [ "${OPBUILD}" ]; then
  get_docker_run_args # to discover siblings
  for i in ${!DOCKER_SIBLINGS[@]}; do
    [ "$(echo $OPBUILD | grep -E "\b$i\b")" ] || OPBUILD+=" ${i}"
  done
  for i in ${OPBUILD}; do
    build_container ${i}
  done
  watch_containers_build
  exit $?
fi

# default is to run the container - but check if it exists first, if not, build it
images="$(docker images | awk '{ print $1 }')"
for i in ${OPDAEMON}; do
  exists=$(grep "${NAME}_${i}" <<< "$images")
  if [ -z "${exists}" ]; then
    build_container ${i}
  fi
done
[ -z "${exists}" ] && watch_containers_build


get_docker_run_args
ticker=25000
for i in ${OPDAEMON}; do
  unset PORT
  inherit_container_environment $i
  nuke_container $i

  echo " * Starting ${NAME}_${i}"

  # if starting on an "auto" port, automatically assign the port to start on
  if [ -z "${PORT}" ] && [ "$(echo ${DOCKER_PORTS[$i]} | grep auto)" ]; then
    ((ticker=ticker+10))
    export PORT=$ticker
  fi

  if [ "${PORT}" ]; then
    ARGS[$i]+=" --publish=${PORT}:${PORT}"
    customport="PORT_${i}"
    export ${customport}=$PORT # for haproxy
  fi

  # run and background the docker process
  nohup docker run --restart=always ${ARGS[$i]} --name=${NAME}_${i} ${NAME}_${i} > /dev/null 2>&1 &

  # artificial delay to permit docker links to work correctly
  [ "${DOCKER_LINKS[$i]}" ] && sleep 0.5
done

# take care of any siblings (eg: a logger or backup sidekick etc)
stop_siblings ${OPDAEMON}
for i in ${OPDAEMON}; do
  for sibling_name in ${!DOCKER_SIBLINGS[@]}; do
    echo " * Starting sibling ${NAME}_${i}_${sibling_name}"
    nohup docker run --restart=always ${ARGS[$sibling_name]} --volumes-from=${NAME}_${i} --name=${NAME}_${i}_${sibling_name} ${NAME}_${sibling_name} > /dev/null 2>&1 &
  done
done


