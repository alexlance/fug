#!/bin/bash

function usage() {
cat << EOF

fug - faster and uglier than fig.

Builds, starts and stops docker containers. Can also be used to view the docker log
files. Uses ./fug.yml for configuration, which is similar syntactically to Fig's fig.yml.

USAGE:

    $(basename $0) [-c FILE] [-d [NAMES]] [-l [NAMES]] [-b [NAMES]] [-s [NAMES]] [-v] [-h]

OPTIONS:

    -c FILE         config file, default: ./fug.yml
    -d [NAMES]      run in daemon mode
    -l [NAMES]      show logs
    -b [NAMES]      build services
    -s [NAMES]      stop containers
    -S [NAMES]      stop containers, remove images
    -v              verbose debugging
    -h              display this help

When run with no arguments, fug will start all services (defined by \$DOCKER_SERVICES)
in the foreground. If the containers haven't been built yet, fug will attempt to build
them.

To build, run, or stop some particular services, use a space separated list of service
NAMES: eg: fug -d service1 service2; fug -l service1 service2; fug -s service1 service2

If no list of NAMES is specified, then the operation will apply to ALL services. Eg:
fug -b; fug -d; fug -l

Fug looks for a fug.yml file that defines the manner in which docker run is invoked for
each service. The fug.yml file supports environment variables in \${SOMEVAR} format and
has an ALL build target for settings that should be applied to all services.

EOF
}

function get_ops() {
  # We are reinventing getopts because I want support for optional parameters,
  # and I want support for space separated non-shell-escaped parameters, eg:
  # fug -b target1 target2 and fug -b. May I offer a hearty F.U. to getopts,
  # getopt et al, get off my lawn!
  #
  # This function populates the global associative array $CLI of the users
  # command line arguments, eg: CLI["-d"]="arg1 arg2"

  local -A FP_START FP_END
  local FLAG=""
  local k=0

  for i in $@; do
    let k=k+1
    if [ "${i:0:1}" == "-" ]; then
      [ -n "${FLAG}" ] && FP_END[$FLAG]=$(($k-${FP_START[$FLAG]}))
      FLAG=${i}
      FP_START[$FLAG]=$(($k+1))
    fi
    [ -n "${FLAG}" ] && [ -z ${FP_END[$FLAG]} ] && FP_END[$FLAG]=${#@}
  done

  for f in ${!FP_START[@]}; do
    if [ -n "${FP_START[$f]}" ]; then
      CLI[$f]=${@:${FP_START[$f]}:${FP_END[$f]}}
    fi
  done
}

# if the flag isn't in here, then it ain't valid
function validate_ops() {
  local -A CLI_VALID CLI_MANDATORY
  # ooh aren't we cheeky, generating the valid cli options from the usage function
  while read -r line; do
    local f=$(echo "$line" | grep -Eo '^\s*-[A-Za-z]')
    local t=$(echo "$line" | grep -Eo '^\s*-[A-Za-z] [A-Za-z]')
    [ "$f" ] && CLI_VALID[$f]=1
    [ "$t" ] && CLI_MANDATORY[$f]=1
  done <<< "$(usage)"

  # loop through the switches the user has typed in
  for i in ${!CLI[@]}; do
    [ -z "${CLI_VALID[$i]}" ] && echo "not supported: $i" && exit 1
    [ "${CLI_MANDATORY[$i]}" ] && [ -z "${CLI[$i]}" ] && echo "empty value for: $i" && exit 1
  done
}

# when a flag is supplied without args
function default_ops() {
  local -A CLI_DEFAULTS
  CLI_DEFAULTS["-d"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-l"]=$DOCKER_SERVICES
  CLI_DEFAULTS["-b"]=$DOCKER_SERVICES_REVERSED
  CLI_DEFAULTS["-s"]=$DOCKER_SERVICES_REVERSED
  CLI_DEFAULTS["-S"]=$DOCKER_SERVICES_REVERSED

  for f in ${!CLI[@]}; do
    if [ -z "${CLI[$f]}" ] && [ "${CLI_DEFAULTS[$f]}" ]; then
      CLI[$f]=${CLI_DEFAULTS[$f]}
    fi
  done
}

function get_docker_run_args() {
  # parse the fug.yml configuration file
  for i in $(${FUGDIR}/shyaml keys < ${OPCONF}); do
    DOCKER_LINKS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.links       < ${OPCONF} | sed 's/- / /g')
    DOCKER_ENV[$i]+=$(    ${FUGDIR}/shyaml get-value ${i}.environment < ${OPCONF} | sed 's/- / /g')
    DOCKER_EXTRA[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.extra       < ${OPCONF} | sed 's/- / /g')
    DOCKER_ROOT[$i]+=$(   ${FUGDIR}/shyaml get-value ${i}.privileged  < ${OPCONF} | sed 's/- / /g')
    DOCKER_PORTS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.ports       < ${OPCONF} | sed 's/- / /g')
    DOCKER_VOLUMES[$i]+=$(${FUGDIR}/shyaml get-value ${i}.volumes     < ${OPCONF} | sed 's/- / /g')
    DOCKER_HOSTS[$i]+=$(  ${FUGDIR}/shyaml get-value ${i}.hosts       < ${OPCONF} | sed 's/- / /g')
    DOCKER_PATH[$i]+=$(   ${FUGDIR}/shyaml get-value ${i}.build       < ${OPCONF} | sed 's/- / /g')
  done

  # if attributes are a part of the ALL target, then apply them to every target
  for i in $DOCKER_SERVICES; do
    [ -n "${DOCKER_LINKS['ALL']}" ]   && DOCKER_LINKS[$i]+=" ${DOCKER_LINKS['ALL']}"
    [ -n "${DOCKER_ENV['ALL']}" ]     && DOCKER_ENV[$i]+=" ${DOCKER_ENV['ALL']}"
    [ -n "${DOCKER_EXTRA['ALL']}" ]   && DOCKER_EXTRA[$i]+=" ${DOCKER_EXTRA['ALL']}"
    [ -n "${DOCKER_ROOT['ALL']}" ]    && DOCKER_ROOT[$i]+=" ${DOCKER_ROOT['ALL']}"
    [ -n "${DOCKER_PORTS['ALL']}" ]   && DOCKER_PORTS[$i]+=" ${DOCKER_PORTS['ALL']}"
    [ -n "${DOCKER_VOLUMES['ALL']}" ] && DOCKER_VOLUMES[$i]+=" ${DOCKER_VOLUMES['ALL']}"
    [ -n "${DOCKER_HOSTS['ALL']}" ]   && DOCKER_HOSTS[$i]+=" ${DOCKER_HOSTS['ALL']}"
    [ -n "${DOCKER_PATH['ALL']}" ]    && DOCKER_PATH[$i]+=" ${DOCKER_PATH['ALL']}"
  done

  # build up command line argument to docker run
  for i in $DOCKER_SERVICES; do
    for v in ${DOCKER_LINKS[$i]};   do ARGS[$i]+=" --link=${NAME}_${v}:${v}"; done
    for v in ${DOCKER_ENV[$i]};     do ARGS[$i]+=" --env=$v";                 done
    for v in ${DOCKER_PORTS[$i]};   do ARGS[$i]+=" --publish=$v";             done
    for v in ${DOCKER_VOLUMES[$i]}; do ARGS[$i]+=" --volume=$v";              done
    for v in ${DOCKER_ROOT[$i]};    do ARGS[$i]+=" --privileged";             done
    for v in ${DOCKER_HOSTS[$i]};   do ARGS[$i]+=" --add-host=$v";            done
    for v in ${DOCKER_EXTRA[$i]};   do ARGS[$i]+=" $v";                       done
  done
}

function stop_containers() {
  local services=$@
  for i in $services; do
    kill1 $i
  done
}

function kill_containers() {
  local services=$@
  for i in $services; do
    kill1 $i
    kill2 $i
    kill3 $i
  done
}

function kill1() {
  local i=$1
  local ids="$(docker ps -a | grep ${NAME}_${i} | awk '{print $1}')"
  for x in $ids; do
    if [ -n "${x}" ]; then
      echo " * Stopping ${NAME}_${i} ($x)"
      docker stop $x > /dev/null
    fi
  done
}

function kill2() {
  local i=$1
  local ids="$(docker ps -a | grep ${NAME}_${i} | awk '{print $1}')"
  for x in $ids; do
    if [ -n "${x}" ]; then
      echo " * Removing ${NAME}_${i} ($x)"
      docker rm -f $x
    fi
  done
}

function kill3() {
  local i=$1
  local ids="$(docker images | grep ${NAME}_${i} | awk '{print $3}')"
  for x in $ids; do
    if [ -n "${x}" ]; then
      echo " * Removing image ${NAME}_${i} ($x)"
      docker rmi -f $x
    fi
  done
}

function halt_log() {
  services=$@
  for i in $services; do
    local ids="$(docker ps | grep ${NAME}_${i} | awk '{print $1}')"
    for i in $ids; do
      if [ -n "${i}" ]; then
        local pid=$(pgrep -f "docker logs -f ${i}")
        [ -n "${pid}" ] && kill $pid
      fi
    done
  done
}

function listen() {
  while true; do
    read x
    sleep 1
  done
}

function build_container() {
  # build new images
  local i=$1
  local p
  echo " * Building $i (${NAME}_${i}) "
  if [ -n "${DOCKER_PATH[$i]}" ]; then
    p=${DOCKER_PATH[$i]}
  else
    p="./${i}/"
  fi
  docker build -t ${NAME}_${i} $p
  if [ "$?" -ne "0" ]; then
    echo "*** Build container failed: $i"
    exit 1
  fi
}

# These are the currently supported docker settings
declare -A DOCKER_LINKS DOCKER_ENV DOCKER_EXTRA DOCKER_ROOT
declare -A DOCKER_PORTS DOCKER_VOLUMES DOCKER_HOSTS DOCKER_PATH

# where `docker run` cli options are constructed
declare -A ARGS

# Location of script
FUGDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

# No services?
[ -z "${DOCKER_SERVICES}" ] && echo "DOCKER_SERVICES is not set" && exit 1
for i in $DOCKER_SERVICES; do DOCKER_SERVICES_REVERSED="$i $DOCKER_SERVICES_REVERSED"; done

# Setup the valid cli options and their defaults
declare -A CLI
get_ops "$@"
validate_ops
default_ops

# make the ops slightly easier to read. The +q hack permits
# checking for array keys that have empty values
[ -n "${CLI["-c"]+q}" ] && OPCONF=${CLI["-c"]}
[ -n "${CLI["-d"]+q}" ] && OPDAEMON=${CLI["-d"]}
[ -n "${CLI["-l"]+q}" ] && OPLOGS=${CLI["-l"]}
[ -n "${CLI["-b"]+q}" ] && OPBUILD=${CLI["-b"]}
[ -n "${CLI["-s"]+q}" ] && OPSTOP=${CLI["-s"]}
[ -n "${CLI["-S"]+q}" ] && OPKILL=${CLI["-S"]}
[ -n "${CLI["-v"]+q}" ] && OPVERBOSE=1
[ -n "${CLI["-h"]+q}" ] && OPHELP=1

# helper monkeys
[ -n "${OPVERBOSE}" ] && env && set -o xtrace
[ -n "${OPHELP}" ]    && usage && exit 0

# get the configuration
[ -z "${OPCONF}" ]    && OPCONF="./fug.yml"
[ ! -f "${OPCONF}" ]  && echo "no configuration file found: ${OPCONF}" && exit 1

# get an alphanumeric name for the containers base on the current working directory
NAME="fug_$(basename $(pwd) | sed 's/[^A-Za-z0-9]//')"

# stop mode
if [ -n "${OPSTOP}" ]; then
  stop_containers ${OPSTOP}
  exit $?
fi

# kill mode
if [ -n "${OPKILL}" ]; then
  kill_containers ${OPKILL}
  exit $?
fi

# show logs
if [ -n "${OPLOGS}" ]; then

  trap "{ halt_log ${OPLOGS} ; exit 0; }" SIGINT
  for i in ${OPLOGS}; do
    id="$(docker ps | grep "${NAME}_${i}" | awk '{print $1}')"
    if [ -n "${id}" ]; then
      docker logs -f $id &
      go=1
    else
      echo "Not started: ${NAME}_${i}"
    fi
  done
  [ -n "${go}" ] && listen
  exit $?
fi


# if not building and not in daemon mode, then control-c stops the containers
if [ -z "${OPBUILD}" ] && [ -z "${OPDAEMON}" ] ; then
  trap "{ stop_containers ${DOCKER_SERVICES_REVERSED}; exit 0; }" SIGINT
fi

# If running -b then build and exit
if [ -n "${OPBUILD}" ]; then
  kill_containers ${OPBUILD}
  for i in ${OPBUILD}; do
    build_container ${i}
  done
  exit $?
fi

services=$DOCKER_SERVICES
[ -n "${OPDAEMON}" ] && services=${OPDAEMON}

# default is to run the container - but check if it exists first if not, build it
for i in $services; do
  exists=$(docker images | grep "${NAME}_${i}")
  if [ -z "${exists}" ]; then
    build_container ${i}
  fi
done

get_docker_run_args
for i in $services; do
  kill1 $i

  echo " * Starting $i"
  cmd="docker run --rm ${ARGS[$i]} --name=${NAME}_${i} ${NAME}_${i}"
  if [ -z "${OPDAEMON}" ]; then
    $cmd &
  else
    nohup $cmd > /dev/null 2>&1 &
  fi
  sleep 0.5
done

# If not in daemon mode then await a control-c/SIGINT
if [ -z "${OPDAEMON}" ]; then
  listen
fi


