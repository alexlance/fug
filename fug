#!/bin/bash


function usage() {
cat << EOF

fug - faster and uglier than fig.

Builds, starts and stops docker containers. Can also be used to view the
containers' log files when fug is invoked in daemon mode. Looks for fug.yml
for configuration - which is syntactically similar to fig's fig.yml.

USAGE:

$(basename $0) [-d] [-l] [-c] [-b NAMES] [-s NAMES] [-v] [-h]

OPTIONS:
   -d                detach and run in daemon mode
   -l                show logs
   -c FILE           configuration file, default: fug.yml
   -b <NAMES>|ALL    build service(s)
   -s <NAMES>|ALL    stop container(s)
   -v                verbose debugging
   -h                display this help

When run with no arguments, fug will start services in the foreground. If the
containers haven't been built yet, fug will attempt to build them.

The fug.yml file also supports environment variables in \${SOMEVAR} format, and
has an ALL build target, that lets you put settings that should be applied to
all services. Additionally the special word ALL can be used with -b and -s args.

Fug supports the "docker run --add-host" option through the "hosts" token in the
fug.yml file.

EOF
}


function stop_containers() {
  for i in "$@"; do
    echo "Stopping ${NAME}_${i}"
    kill1 $i
    kill2 $i
  done
}

function kill1() {
  local i=$1
  local id="$(docker ps -a | grep ${NAME}_${i} | awk '{print $1}')"
  for x in $id; do
    if [ -n "${x}" ]; then
      echo " * Stopping $x"
      docker stop $x
    fi
  done
}

function kill2() {
  local i=$1
  local id="$(docker ps -a | grep ${NAME}_${i} | awk '{print $1}')"
  for x in $id; do
    if [ -n "${x}" ]; then
      echo " * Removing $x"
      docker rm -f $x
    fi
  done
}

function kill3() {
  local i=$1
  local id="$(docker images | grep ${NAME}_${i} | awk '{print $3}')"
  for x in $id; do
    if [ -n "${x}" ]; then
      echo " * Removing image $x"
      docker rmi -f $x
    fi
  done
}

function halt_log() {
  for i in $DOCKER_SERVICES; do
    local id="$(docker ps | grep ${NAME}_${i} | awk '{print $1}')"
    for i in $id; do
      if [ -n "${i}" ]; then
        local pid=$(pgrep -f "docker logs -f ${i}")
        [ -n "${pid}" ] && kill $pid
      fi
    done
  done
}

function listen() {
  while true; do
    read x
    sleep 1
  done
}

function build_container() {
  # build new images
  local i=$1
  local p
  echo "* Building $i ... (${NAME}_${i}) "
  if [ -n "${DOCKER_PATH[$i]}" ]; then
    p=${DOCKER_PATH[$i]}
  else
    p="./${i}/"
  fi
  docker build -t ${NAME}_${i} $p
  if [ "$?" -ne "0" ]; then
    echo "*** Build container failed: $i ***"
    exit 1
  fi
}

# These are the currently supported fug settings
declare -A DOCKER_LINKS DOCKER_ENV DOCKER_EXTRA DOCKER_ROOT DOCKER_PORTS DOCKER_VOLUMES DOCKER_HOSTS DOCKER_PATH

# parse command line options
while getopts "b:dSs:lc:vh" OPTION
do
  case $OPTION in
    b) OPBUILD=1; OPBUILD_CONTAINER=$OPTARG ;;
    d) OPDAEMON=1 ;;
    s) OPSTOP=1; OPSTOP_CONTAINER=$OPTARG ;;
    l) OPLOGS=1 ;;
    c) OPCONF=$OPTARG ;;
    v) OPVERBOSE=1 ;;
    h) OPHELP=1 ;;
    ?) usage && exit 1 ;;
  esac
done

# helper monkeys
[ -n "${OPVERBOSE}" ] && env && set -o xtrace
[ -n "${OPHELP}" ]    && usage && exit 0

# No services?
[ -z "${DOCKER_SERVICES}" ] && echo "DOCKER_SERVICES is not set" && exit 1
for i in $DOCKER_SERVICES; do DOCKER_SERVICES_REVERSED="$i $DOCKER_SERVICES_REVERSED"; done

# get the configuration
[ -z "${OPCONF}" ]    && OPCONF="./fug.yml"
[ ! -f "${OPCONF}" ]  && echo "No fug.yml configuration file found" && exit 1


# get an alphanumeric name for the containers base on the current working directory
NAME="fug_$(basename $(pwd) | sed 's/[^A-Za-z0-9]//')"

# kill mode
if [ -n "${OPSTOP}" ]; then
  [ "${OPSTOP_CONTAINER}" == "ALL" ] && OPSTOP_CONTAINER=$DOCKER_SERVICES_REVERSED
  stop_containers $OPSTOP_CONTAINER
  exit $?

# show logs
elif [ -n "${OPLOGS}" ]; then

  trap "{ halt_log ; exit 0; }" SIGINT
  for i in $DOCKER_SERVICES; do
    id="$(docker ps | grep "${NAME}_${i}" | awk '{print $1}')"
    if [ -n "${id}" ]; then
      docker logs -f $id &
    fi
  done

  listen
  exit $?

# in daemon mode we run --detach, which backgrounds the docker run commands
elif [ -n "${OPDAEMON}" ]; then
  DOCKER_EXTRA["ALL"]+=" --detach"

# if not in daemon mode, then control-c stops the containers
elif [ -z "${OPBUILD}" ]; then 
  trap "{ stop_containers ${DOCKER_SERVICES_REVERSED}; exit 0; }" SIGINT
  DOCKER_EXTRA["ALL"]+=" --rm"
fi


# parse the fug.yml configuration file
for i in $(./shyaml keys < fug.yml); do
  DOCKER_LINKS[$i]+=$(  ./shyaml get-value ${i}.links       < ./fug.yml | sed 's/- / /g')
  DOCKER_ENV[$i]+=$(    ./shyaml get-value ${i}.environment < ./fug.yml | sed 's/- / /g')
  DOCKER_EXTRA[$i]+=$(  ./shyaml get-value ${i}.extra       < ./fug.yml | sed 's/- / /g')
  DOCKER_ROOT[$i]+=$(   ./shyaml get-value ${i}.privileged  < ./fug.yml | sed 's/- / /g')
  DOCKER_PORTS[$i]+=$(  ./shyaml get-value ${i}.ports       < ./fug.yml | sed 's/- / /g')
  DOCKER_VOLUMES[$i]+=$(./shyaml get-value ${i}.volumes     < ./fug.yml | sed 's/- / /g')
  DOCKER_HOSTS[$i]+=$(  ./shyaml get-value ${i}.hosts       < ./fug.yml | sed 's/- / /g')
  DOCKER_PATH[$i]+=$(   ./shyaml get-value ${i}.build       < ./fug.yml | sed 's/- / /g')
done

# build up the command line arguments to docker
declare -A ARGS

# if attributes are a part of the ALL target, then apply them to every target
for i in $DOCKER_SERVICES; do
  [ -n "${DOCKER_LINKS['ALL']}" ]   && DOCKER_LINKS[$i]+=" ${DOCKER_LINKS['ALL']}"
  [ -n "${DOCKER_ENV['ALL']}" ]     && DOCKER_ENV[$i]+=" ${DOCKER_ENV['ALL']}"
  [ -n "${DOCKER_PORTS['ALL']}" ]   && DOCKER_PORTS[$i]+=" ${DOCKER_PORTS['ALL']}"
  [ -n "${DOCKER_VOLUMES['ALL']}" ] && DOCKER_VOLUMES[$i]+=" ${DOCKER_VOLUMES['ALL']}"
  [ -n "${DOCKER_ROOT['ALL']}" ]    && DOCKER_ROOT[$i]+=" ${DOCKER_ROOT['ALL']}"
done

# build up command line argument to docker run
for i in $DOCKER_SERVICES; do
  for v in ${DOCKER_LINKS[$i]};   do ARGS[$i]+=" --link=${NAME}_${v}:${v}"; done
  for v in ${DOCKER_ENV[$i]};     do ARGS[$i]+=" --env=$v";                 done
  for v in ${DOCKER_PORTS[$i]};   do ARGS[$i]+=" --publish=$v";             done
  for v in ${DOCKER_VOLUMES[$i]}; do ARGS[$i]+=" --volume=$v";              done
  for v in ${DOCKER_ROOT[$i]};    do ARGS[$i]+=" --privileged";             done
  for v in ${DOCKER_EXTRA[$i]};   do ARGS[$i]+=" $v";                       done
done


# If running -b then build and exit
if [ -n "${OPBUILD}" ] && [ -n "${OPBUILD_CONTAINER}" ]; then
  [ "${OPBUILD_CONTAINER}" == "ALL" ] && OPBUILD_CONTAINER=$DOCKER_SERVICES_REVERSED

  for i in $OPBUILD_CONTAINER; do
    kill1 ${i}
    kill2 ${i}
    kill3 ${i}
  done
  for i in $OPBUILD_CONTAINER; do
    build_container ${i}
  done
  exit $?
fi


# default is to run the container - but check if it exists first if not, build it
for i in $DOCKER_SERVICES; do 
  exists=$(docker images | grep "${NAME}_${i}")
  if [ -z "${exists}" ]; then
    build_container ${i}
  fi
done

for i in $DOCKER_SERVICES; do 
  kill1 $i
  kill2 $i

  echo "* Starting $i ... "
  cmd="docker run ${ARGS[$i]} --name=${NAME}_${i} ${NAME}_${i}"
  $cmd &
  sleep 0.5
done

# If not in daemon mode then await a control-c/SIGINT
if [ -z "${OPDAEMON}" ]; then
  listen
fi


